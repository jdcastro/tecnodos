{# index.j2 #}
{% extends "base.j2" %}
{% set dashboard = true %}
{% from "settings/_ui_class.j2" import base_button_classes, input_bg_color, border_color, hover_bg_color, focus_ring_color, button_bg_color, delete_button_bg_color, input_focus_bg_color, text_color %}
{% from "macros/_forms.j2" import render_alert %}

{% block extra_css %}
  {{ css_code|safe }}
  {{ super() }}
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    /* --- Layout: right split (sidebar | map) --- */
    #right-split{
      display:grid;
      grid-template-columns:320px 1fr;
      gap:1rem;
      height:calc(100vh - 56px);
    }
    #map{ height:100%; position:relative; }

    /* Keep space for right ruler (+ shift default right controls) */
    :root { --ruler-right-w: 64px; }
    #map .leaflet-top.leaflet-right{ right:var(--ruler-right-w,64px); }

    /* Drop left controls by 40px to avoid top ruler overlap */
    .leaflet-top.leaflet-left{ top:40px; }

    .leaflet-top,.leaflet-bottom{ pointer-events:none; }
    .leaflet-control{ pointer-events:auto; }

    /* Sidebar with internal scroll without stretching the grid */
    .vars-panel{
      display:flex; flex-direction:column; overflow:hidden;
    }
    .vars-scroll{ overflow:auto; }

    /* (Optional) Hide Leaflet attribution – keep it visible in production to respect license */
    .leaflet-control-attribution.leaflet-control {
      display:none !important; visibility:hidden !important; opacity:0 !important; pointer-events:none !important;
    }
  </style>
{% endblock %}

{% block extra_head %}
  {{ js_code|safe }}
  {{ super() }}
{% endblock %}

{% block content %}
<div id="workzone" class="bg-white p-5">
  <!-- Top bar -->
  <div class="mb-3 flex gap-2 justify-center">
    <button id="enter-fullscreen" class="{{ base_button_classes }}" title="Pantalla completa" aria-label="Pantalla completa">Pantalla completa</button>
    <button id="exit-fullscreen"  class="{{ base_button_classes }} hidden" title="Salir pantalla completa" aria-label="Salir pantalla completa">Salir pantalla completa</button>
    <button id="fit-bounds"       class="{{ base_button_classes }}" title="Ajustar imagen" aria-label="Ajustar imagen">Ajustar imagen</button>
    <button id="open-media-picker" class="{{ base_button_classes }}" title="Seleccionar desde Media" aria-label="Seleccionar desde Media">Seleccionar archivo</button>
    <input type="file" id="uploader" accept=".tif,.tiff,.jp2" class="hidden" />
  </div>

  <!-- Right side -->
  <div id="right-split">
    <!-- Variables -->
    <aside class="vars-panel border rounded-lg p-4 bg-gray-50">
      <div class="vars-scroll space-y-3">
        <strong id="status" class="block text-sm" aria-live="polite">Sube un GeoTIFF con NIR</strong>

        <div id="area" class="p-2 border rounded text-sm">
          <h3 class="font-semibold mb-2">Área</h3>
          <div id="area-box" aria-live="polite">Selecciona un polígono</div>
        </div>

        <div id="protein-box" class="p-2 border rounded text-sm" aria-live="polite">
          Promedio de proteína: --%
        </div>

        <div>
          <h3 class="font-semibold mb-2">Variables</h3>
          <ul id="variables" class="space-y-2">
            <li class="text-sm">Nitrógeno</li>
            <li class="text-sm">VI</li>
            <li class="text-sm">GLI</li>
            <li class="text-sm">VARI</li>
          </ul>
        </div>

        <hr class="my-4">
      </div>
    </aside>

    <!-- Map -->
    <section class="relative border rounded-lg overflow-hidden">
      <div id="map"></div>
    </section>
  </div>
</div>
{% endblock %}

{% block extra_js %}
  {{ js_code|safe }}
  {{ super() }}
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script>
  // --- Media Picker Modal Styles ---
  (function(){
    const style = document.createElement('style');
    style.textContent = `
      .media-picker-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: none; }
      .media-picker-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 1001; }
      .media-picker-panel { width: 80vw; max-width: 1280px; max-height: 80vh; overflow: hidden; border-radius: 12px; background: var(--mp-bg, #fff); border: 1px solid rgba(0,0,0,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
      .dark .media-picker-panel { --mp-bg: #0b0f19; }
      .media-picker-header { display:flex; align-items:center; justify-content:space-between; padding: 10px 14px; border-bottom: 1px solid rgba(0,0,0,0.1); }
      .media-picker-body { display:grid; grid-template-columns: 260px 1fr; gap: 12px; padding: 12px; height: calc(80vh - 52px); }
      .media-picker-sidebar { overflow:auto; }
      .media-picker-grid { overflow:auto; }
    `;
    document.head.appendChild(style);
  })();

  /* -------------------------------
   * Map UI Module (IIFE)
   * Responsibilities: state, utils, map init, rulers, upload, draw events, fullscreen
   * ------------------------------- */
  (function(){
    "use strict";

    /* ---------- Config ---------- */
    const ENDPOINTS = {
      upload: "/api/agrovista/upload",
      image:  (id) => `/api/agrovista/image/${id}.png`,
      protein:"/api/agrovista/protein"
    };
    const RIGHT_RULER_W = 64;  // px
    const TOP_RULER_H   = 28;  // px

    /* ---------- State ---------- */
    let imageId = null;
    let imageWidth = 0, imageHeight = 0;
    let mppX = null, mppY = null; // meters-per-pixel
    let overlay = null, imgBounds = null;

    /* ---------- DOM ---------- */
    const el = {
      workzone: document.getElementById("workzone"),
      map:      document.getElementById("map"),
      status:   document.getElementById("status"),
      areaBox:  document.getElementById("area-box"),
      protein:  document.getElementById("protein-box"),
      uploader: document.getElementById("uploader"),
      btnFit:   document.getElementById("fit-bounds"),
      btnFsIn:  document.getElementById("enter-fullscreen"),
      btnFsOut: document.getElementById("exit-fullscreen"),
      btnOpenPicker: document.getElementById("open-media-picker"),
    };

    /* Ensure area box exists in DOM */
    if(!el.areaBox){
      const container = document.querySelector("#area") || document.body;
      const d = document.createElement("div");
      d.id = "area-box"; d.className = "p-2 border rounded text-sm";
      d.textContent = "Selecciona un polígono";
      d.setAttribute("aria-live","polite");
      container.appendChild(d);
      el.areaBox = d;
    }

    /* ---------- Utils ---------- */
    // Nice step length selector for scales
    function niceStep(length){
      const seeds = [1,2,5];
      const p = Math.pow(10, Math.floor(Math.log10(length || 1)));
      let best = p;
      for(const s of seeds){
        const cand = s * p;
        if(cand <= length) best = cand;
        if(cand >= length * 0.6) return cand;
      }
      return best;
    }
    function fmtLinear(m){
      if(m >= 1000) return (m/1000).toFixed(m % 1000 === 0 ? 0 : 1) + " km";
      if(m >= 1)    return Math.round(m) + " m";
      return (m*100).toFixed(0) + " cm";
    }
    function fmtAreaMeters(m2){
      if(m2 >= 1e6) return (m2/1e6).toFixed(m2 % 1e6 === 0 ? 0 : 2) + " km²";
      if(m2 >= 1e4) return (m2/1e4).toFixed(2) + " ha";
      if(m2 >= 1)   return Math.round(m2) + " m²";
      return (m2*1e4).toFixed(0) + " cm²";
    }
    function fmtPixels(px){ return Math.round(px) + " px"; }
    function fmtAreaPx2(px2){
      if(mppX != null){
        const _mppY = (mppY != null) ? mppY : mppX;
        const m2 = px2 * mppX * _mppY;
        return fmtAreaMeters(m2);
      }
      return Math.round(px2) + " px²";
    }
    // Shoelace area in "map units" (CRS.Simple => lat=Y, lng=X)
    function polygonAreaPx2(latlngs){
      const pts = latlngs.map(ll => [ll.lng, ll.lat]);
      let s = 0;
      for(let i=0, n=pts.length; i<n; i++){
        const [x1,y1] = pts[i];
        const [x2,y2] = pts[(i+1)%n];
        s += x1*y2 - x2*y1;
      }
      return Math.abs(s)/2;
    }
    function setStatus(msg){ if(el.status) el.status.textContent = msg; }

    /* ---------- Media Picker (Modal) ---------- */
    const MP = (()=>{
      const back = document.createElement('div'); back.className = 'media-picker-backdrop';
      const wrap = document.createElement('div'); wrap.className = 'media-picker-modal';
      const panel = document.createElement('div'); panel.className = 'media-picker-panel';

      wrap.appendChild(panel);
      document.body.appendChild(back);
      document.body.appendChild(wrap);

      const html = `
        <div class="media-picker-header">
          <div class="flex items-center gap-3">
            <strong class="text-base">Biblioteca de Medios</strong>
            <span class="text-xs text-gray-500">Selecciona un GeoTIFF</span>
          </div>
          <div class="flex items-center gap-2">
            <button id="mp-close" class="px-2 py-1 rounded border">Cerrar</button>
          </div>
        </div>
        <div class="media-picker-body">
          <aside class="media-picker-sidebar">
            <div class="space-y-3">
              <div>
                <label class="block text-xs mb-1">Buscar</label>
                <input id="mp-q" type="text" class="w-full px-2 py-1 rounded border" placeholder="Nombre..." />
              </div>
              <div>
                <label class="block text-xs mb-1">Tipo</label>
                <select id="mp-type" class="w-full px-2 py-1 rounded border">
                  <option value="geotiff">GeoTIFF</option>
                  <option value="image">Imágenes</option>
                  <option value="all">Todos</option>
                </select>
              </div>
              <div>
                <label class="block text-xs mb-1">Subir nuevo</label>
                <input id="mp-upload" type="file" accept=".tif,.tiff,.png,.jpg,.jpeg" class="block w-full text-sm" />
                <small id="mp-upload-msg" class="text-xs"></small>
              </div>
            </div>
          </aside>
          <section class="media-picker-grid">
            <div id="mp-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3"></div>
          </section>
        </div>
      `;
      panel.innerHTML = html;

      const st = { items: [], type: 'geotiff', q: '' };
      const ui = {
        grid: panel.querySelector('#mp-grid'),
        q: panel.querySelector('#mp-q'),
        type: panel.querySelector('#mp-type'),
        btnClose: panel.querySelector('#mp-close'),
        upload: panel.querySelector('#mp-upload'),
        uploadMsg: panel.querySelector('#mp-upload-msg'),
      };

      function getCookie(name){
        const v = `; ${document.cookie}`; const p = v.split(`; ${name}=`);
        if(p.length === 2) return p.pop().split(';').shift();
      }

      async function fetchAssets(){
        try{
          const res = await fetch('{{ url_for('media_api.list_assets') }}', { credentials: 'include' });
          const data = await res.json();
          if(Array.isArray(data)) st.items = data; else st.items = [];
          render();
        }catch(e){ st.items = []; render(); }
      }

      function matches(it){
        const okType = st.type === 'all' ? true : (it.asset_type === st.type);
        const okQ = st.q ? (it.original_name?.toLowerCase().includes(st.q)) : true;
        return okType && okQ;
      }
      function fileUrl(it){ return '{{ url_for('media.serve_file', key='__KEY__') }}'.replace('__KEY__', encodeURIComponent(it.storage_key)); }

      function render(){
        const items = st.items.filter(matches);
        const frag = document.createDocumentFragment();
        for(const it of items){
          const card = document.createElement('div');
          card.className = 'rounded border overflow-hidden';
          const isImg = (it.ext === 'png' || it.ext === 'jpg' || it.ext === 'jpeg');
          const isTif = (it.ext === 'tif' || it.ext === 'tiff');
          card.innerHTML = `
            <div class="aspect-video bg-gray-100 flex items-center justify-center">
              ${isImg ? `<img src="${fileUrl(it)}" alt="${it.original_name}" class="w-full h-full object-cover"/>` : `<span class="text-xs px-2 py-1 rounded bg-gray-200">${it.ext?.toUpperCase() || ''}</span>`}
            </div>
            <div class="p-2 flex items-center justify-between gap-2">
              <div class="min-w-0"><div class="truncate text-sm" title="${it.original_name}">${it.original_name}</div><div class="text-xs text-gray-500">${it.width||'?'}×${it.height||'?'} • ${(it.size_bytes/1024).toFixed(1)} KB</div></div>
              <button class="px-2 py-1 text-xs rounded ${isTif ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-600'}" ${isTif? '' : 'disabled'} data-id="${it.id}">Seleccionar</button>
            </div>`;
          frag.appendChild(card);
        }
        ui.grid.innerHTML = '';
        ui.grid.appendChild(frag);
      }

      async function selectById(id){
        const it = st.items.find(x => x.id == id);
        if(!it) return;
        try{
          const resp = await fetch(fileUrl(it), { credentials: 'include' });
          const blob = await resp.blob();
          const file = new File([blob], it.original_name || ('asset_'+id+'.tif'), { type: it.mime || 'image/tiff' });
          await onPick(file); // calls back into NDVI flow
          hide();
        }catch(e){ alert('No se pudo obtener el archivo seleccionado'); }
      }

      function onGridClick(ev){
        const btn = ev.target.closest('button[data-id]');
        if(!btn) return; selectById(btn.getAttribute('data-id'));
      }

      async function handleUpload(ev){
        const file = ev.target.files && ev.target.files[0];
        if(!file) return;
        ui.uploadMsg.textContent = 'Subiendo...'; ui.uploadMsg.className = 'text-xs text-gray-600';
        try{
          const fd = new FormData(); fd.append('file', file, file.name);
          const csrf = getCookie('csrf_access_token');
          const res = await fetch('{{ url_for('media_api.upload_local_api') }}', {
            method: 'POST', credentials: 'include', headers: { 'X-CSRF-TOKEN': csrf || '' }, body: fd
          });
          const data = await res.json().catch(()=>({}));
          if(res.ok){
            ui.uploadMsg.textContent = 'Subido. Procesando...'; ui.uploadMsg.className = 'text-xs text-green-700';
            // Use same file for NDVI processing immediately
            await onPick(file);
            hide();
          }else{
            ui.uploadMsg.textContent = data.message || 'Error al subir'; ui.uploadMsg.className = 'text-xs text-red-700';
          }
        }catch(err){ ui.uploadMsg.textContent = 'Error de red'; ui.uploadMsg.className = 'text-xs text-red-700'; }
        finally{ ev.target.value = ''; }
      }

      function show(){ back.style.display='block'; wrap.style.display='flex'; fetchAssets(); }
      function hide(){ back.style.display='none'; wrap.style.display='none'; }

      function wire(){
        ui.btnClose.addEventListener('click', hide);
        back.addEventListener('click', hide);
        ui.grid.addEventListener('click', onGridClick);
        ui.upload.addEventListener('change', handleUpload);
        ui.q.addEventListener('input', (e)=>{ st.q = String(e.target.value||'').trim().toLowerCase(); render(); });
        ui.type.addEventListener('change', (e)=>{ st.type = String(e.target.value||'geotiff'); render(); });
      }

      let onPick = async (_file)=>{}; // callback setter
      wire();
      return { show, hide, setOnPick: (fn)=>{ onPick = fn; } };
    })();

    /* ---------- Leaflet Map ---------- */
    const map = L.map("map", { crs: L.CRS.Simple }).setView([0,0], 0);

    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawCtl = new L.Control.Draw({
      draw:{ polygon:true, rectangle:true, polyline:false, circle:false, marker:false, circlemarker:false },
      edit:{ featureGroup: drawnItems }
    });
    map.addControl(drawCtl);

    /* Simple scale control that respects mpp if present */
    function addSimpleScaleControl(getMppX){
      const ScaleCtl = L.Control.extend({
        options:{ position:"bottomleft" },
        onAdd:function(){
          const box = L.DomUtil.create("div","leaflet-control scale-simple");
          Object.assign(box.style, {
            background:"rgba(255,255,255,0.9)",
            padding:"6px 8px",
            border:"1px solid #ddd",
            borderRadius:"6px",
            font:"12px/1.2 system-ui, sans-serif",
            userSelect:"none"
          });
          this._label = document.createElement("div");
          this._label.style.textAlign = "center";
          this._bar = document.createElement("div");
          Object.assign(this._bar.style, { height:"6px", marginTop:"4px", background:"#333", width:"100px" });
          box.appendChild(this._label);
          box.appendChild(this._bar);
          map.on("zoom move resize", this._update, this);
          this._container = box;
          this._update();
          return box;
        },
        onRemove:function(){ map.off("zoom move resize", this._update, this); },
        _update:function(){
          if(!this._container) return;
          const mpp = getMppX();
          const S = 150; // px sample span
          const a = map.containerPointToLatLng([0,0]);
          const b = map.containerPointToLatLng([S,0]);
          const units = Math.abs(b.lng - a.lng);
          const totalMeters = (mpp != null) ? units * mpp : null;

          let label, barPx;
          if(totalMeters != null){
            const n = niceStep(totalMeters);
            label = fmtLinear(n);
            barPx = S * (n / totalMeters);
          } else {
            const n = niceStep(units);
            label = fmtPixels(n);
            barPx = S * (n / units);
          }
          this._label.textContent = label;
          this._bar.style.width = Math.max(30, Math.min(220, barPx)) + "px";
        }
      });
      map.addControl(new ScaleCtl());
    }
    addSimpleScaleControl(() => mppX);

    /* ---------- Rulers (Top & Right Canvases) ---------- */
    const rulerTop = document.createElement("canvas");
    const rulerRight = document.createElement("canvas");
    Object.assign(rulerTop.style,  { position:"absolute", right:"0", top:"0", height:TOP_RULER_H+"px", width:"100%", pointerEvents:"none", zIndex:500 });
    Object.assign(rulerRight.style,{ position:"absolute", right:"0", top:"0", width:RIGHT_RULER_W+"px", height:"100%", pointerEvents:"none", zIndex:500 });
    el.map.appendChild(rulerTop);
    el.map.appendChild(rulerRight);
    el.map.style.setProperty("--ruler-right-w", RIGHT_RULER_W + "px");

    function drawRulers(){
      const rect = el.map.getBoundingClientRect();

      // Top ruler
      rulerTop.width = Math.max(1, Math.floor(rect.width));
      rulerTop.height = TOP_RULER_H;
      const ctxT = rulerTop.getContext("2d");
      ctxT.clearRect(0,0,rulerTop.width,rulerTop.height);
      ctxT.fillStyle = "rgba(255,255,255,0.9)";
      ctxT.fillRect(0,0,rulerTop.width,rulerTop.height);
      ctxT.strokeStyle = "#333"; ctxT.fillStyle = "#333"; ctxT.lineWidth = 1;
      ctxT.beginPath(); ctxT.moveTo(0, TOP_RULER_H - 0.5); ctxT.lineTo(rulerTop.width, TOP_RULER_H - 0.5); ctxT.stroke();

      // Right ruler
      rulerRight.width  = RIGHT_RULER_W;
      rulerRight.height = Math.max(1, Math.floor(rect.height));
      const ctxR = rulerRight.getContext("2d");
      ctxR.clearRect(0,0,rulerRight.width,rulerRight.height);
      ctxR.fillStyle = "rgba(255,255,255,0.9)";
      ctxR.fillRect(0,0,rulerRight.width,rulerRight.height);
      ctxR.strokeStyle = "#333"; ctxR.fillStyle = "#333"; ctxR.lineWidth = 1;
      ctxR.beginPath(); ctxR.moveTo(rulerRight.width - 0.5, 0); ctxR.lineTo(rulerRight.width - 0.5, rulerRight.height); ctxR.stroke();

      const sample = 200; // px sample distance for unit computation
      const a = map.containerPointToLatLng([0,0]);
      const b = map.containerPointToLatLng([sample,0]);
      const c = map.containerPointToLatLng([0,sample]);
      const unitPerPxX = Math.abs(b.lng - a.lng) / sample;
      const unitPerPxY = Math.abs(c.lat - a.lat) / sample;

      const mX = (mppX != null) ? unitPerPxX * mppX : null;
      const _mppY = (mppY != null) ? mppY : mppX;
      const mY = (_mppY != null) ? unitPerPxY * _mppY : null;

      // Top ticks
      const wantX = 140;
      const spanUnitsX = unitPerPxX * wantX;
      const spanMetersX = (mX != null) ? mX * wantX : null;
      let stepUX, labelXFn;
      if(spanMetersX != null){
        const s = niceStep(spanMetersX);
        stepUX = s / (mppX || 1);
        labelXFn = (units) => fmtLinear(units * (mppX || 1));
      } else {
        const s = niceStep(spanUnitsX);
        stepUX = s;
        labelXFn = (units) => fmtPixels(units);
      }
      const x0 = a.lng;
      const firstX = Math.ceil(x0 / stepUX) * stepUX;
      ctxT.font = "11px system-ui"; ctxT.textAlign = "center"; ctxT.textBaseline = "top";
      for(let u = firstX;; u += stepUX){
        const sx = (u - x0) / unitPerPxX;
        if(sx > rulerTop.width) break;
        if(sx < 0) { if(u > x0) break; else continue; }
        ctxT.beginPath(); ctxT.moveTo(Math.round(sx)+0.5, TOP_RULER_H - 12); ctxT.lineTo(Math.round(sx)+0.5, TOP_RULER_H); ctxT.stroke();
        ctxT.fillText(labelXFn(stepUX), Math.round(sx), 2);
      }

      // Right ticks
      const wantY = 90;
      const spanUnitsY = unitPerPxY * wantY;
      const spanMetersY = (mY != null) ? mY * wantY : null;
      let stepUY, labelYFn;
      if(spanMetersY != null){
        const s = niceStep(spanMetersY);
        stepUY = s / (_mppY || 1);
        labelYFn = (units) => fmtLinear(units * (_mppY || 1));
      } else {
        const s = niceStep(spanUnitsY);
        stepUY = s;
        labelYFn = (units) => fmtPixels(units);
      }
      const y0 = a.lat;
      const firstY = Math.ceil(y0 / stepUY) * stepUY;
      ctxR.font = "11px system-ui"; ctxR.textAlign = "right"; ctxR.textBaseline = "middle";
      const textPad = 8; // left padding for text inside RIGHT_RULER_W
      for(let u = firstY;; u += stepUY){
        const sy = (u - y0) / unitPerPxY;
        if(sy > rulerRight.height) break;
        if(sy < 0) { if(u > y0) break; else continue; }
        ctxR.beginPath(); ctxR.moveTo(RIGHT_RULER_W - 12, Math.round(sy)+0.5);
        ctxR.lineTo(RIGHT_RULER_W, Math.round(sy)+0.5); ctxR.stroke();
        ctxR.fillText(labelYFn(stepUY), RIGHT_RULER_W - textPad, Math.round(sy));
      }
    }
    function scheduleRulersRedraw(){ requestAnimationFrame(drawRulers); }
    map.on("zoom move resize", scheduleRulersRedraw);
    window.addEventListener("resize", scheduleRulersRedraw);
    setTimeout(scheduleRulersRedraw, 0);

    /* ---------- View helpers ---------- */
    function fitImage(){
      if(!overlay || !imgBounds) return;
      map.invalidateSize();
      const size = map.getSize();
      const scale = Math.min(size.x / imageWidth, size.y / imageHeight);
      const minZoom = Math.min(0, Math.floor(Math.log2(scale)));
      map.setMinZoom(minZoom);
      map.fitBounds(imgBounds);
      scheduleRulersRedraw();
    }
    function updateAreaForLayer(layer){
      const rings = layer.getLatLngs();
      const latlngs = Array.isArray(rings[0]) ? rings[0] : rings;
      if(!latlngs || latlngs.length < 3){ el.areaBox.textContent = "—"; return; }
      const px2 = polygonAreaPx2(latlngs);
      el.areaBox.textContent = "Área: " + fmtAreaPx2(px2);
    }

    /* ---------- Upload ---------- */
    async function uploadFile(file){
      const fd = new FormData(); fd.append("file", file);
      const res = await fetch(ENDPOINTS.upload, { method:"POST", body: fd });
      if(!res.ok){
        let msg = "Upload error";
        try{ msg = await res.text(); } catch {}
        throw new Error(msg);
      }
      return res.json();
    }
    function applyMeta(meta){
      imageId = meta.id;
      imageWidth  = meta.width;
      imageHeight = meta.height;
      mppX = (typeof meta.mppX === "number" && isFinite(meta.mppX)) ? meta.mppX : null;
      mppY = (typeof meta.mppY === "number" && isFinite(meta.mppY)) ? meta.mppY : null;
      imgBounds = [[0,0], [imageHeight, imageWidth]];
    }
    async function handleFileChange(ev){
      const file = ev.target.files?.[0];
      if(!file) return;
      try{
        setStatus("Procesando...");
        const meta = await uploadFile(file);
        applyMeta(meta);
        if(overlay) map.removeLayer(overlay);
        overlay = L.imageOverlay(ENDPOINTS.image(imageId), imgBounds).addTo(map);
        fitImage();
        setStatus(mppX != null ? `Escala automática: ~${mppX} m/px` : "Escala en píxeles (mpp no disponible)");
        drawnItems.eachLayer(layer => { if(layer instanceof L.Polygon || layer instanceof L.Rectangle){ updateAreaForLayer(layer); } });
      }catch(e){
        setStatus("Error al procesar el archivo");
      }
    }

    // Picker callback uses same flow as local upload
    MP.setOnPick(async (file)=>{
      try{
        setStatus("Procesando...");
        const meta = await uploadFile(file);
        applyMeta(meta);
        if(overlay) map.removeLayer(overlay);
        overlay = L.imageOverlay(ENDPOINTS.image(imageId), imgBounds).addTo(map);
        fitImage();
        setStatus(mppX != null ? `Escala automática: ~${mppX} m/px` : "Escala en píxeles (mpp no disponible)");
        drawnItems.eachLayer(layer => { if(layer instanceof L.Polygon || layer instanceof L.Rectangle){ updateAreaForLayer(layer); } });
      }catch(e){ setStatus("Error al procesar el archivo"); }
    });

    /* ---------- Draw events ---------- */
    async function fetchProtein(verts){
      const res = await fetch(ENDPOINTS.protein, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ id:imageId, vertices: verts })
      });
      let data = {};
      try{ data = await res.json(); }catch{}
      if(!res.ok){ throw new Error(data?.description || "Área inválida"); }
      return data;
    }
    function wireArea(layer){ layer.on("click", () => updateAreaForLayer(layer)); }

    map.on(L.Draw.Event.CREATED, async (e)=>{
      const { layer, layerType } = e;
      drawnItems.addLayer(layer);

      if(layerType === "polygon" || layerType === "rectangle"){
        wireArea(layer);
        updateAreaForLayer(layer);

        if(imageId){
          try{
            const latlngs = layer.getLatLngs()[0];
            const verts = latlngs.map(ll => [ll.lng, ll.lat]);
            const data = await fetchProtein(verts);
            el.protein.textContent = `Promedio de proteína: ${data.protein}%`;
          }catch(err){
            el.protein.textContent = err?.message || "Error al calcular la proteína";
          }
        }
      }
    });

    map.on(L.Draw.Event.EDITED, (e)=>{
      e.layers.eachLayer(layer => {
        if(layer instanceof L.Polygon || layer instanceof L.Rectangle){
          updateAreaForLayer(layer);
        }
      });
    });
    map.on(L.Draw.Event.DELETED, ()=>{
      el.areaBox.textContent = "Selecciona un polígono";
    });

    /* ---------- Fullscreen ---------- */
    function enterFullscreen(){
      el.workzone.requestFullscreen().catch(()=>{});
      setTimeout(() => { map.invalidateSize(); scheduleRulersRedraw(); }, 80);
    }
    function exitFullscreen(){ document.exitFullscreen(); }
    function onFsChange(){
      const isFs = document.fullscreenElement === el.workzone;
      el.btnFsIn.classList.toggle("hidden", isFs);
      el.btnFsOut.classList.toggle("hidden", !isFs);
      setTimeout(() => { map.invalidateSize(); scheduleRulersRedraw(); }, 80);
    }

    /* ---------- Wire UI Events ---------- */
    if(el.uploader) el.uploader.addEventListener("change", handleFileChange);
    el.btnFit.addEventListener("click", fitImage);
    el.btnFsIn.addEventListener("click", enterFullscreen);
    el.btnFsOut.addEventListener("click", exitFullscreen);
    document.addEventListener("fullscreenchange", onFsChange);
    window.addEventListener("resize", () => { map.invalidateSize(); scheduleRulersRedraw(); });
    if(el.btnOpenPicker){ el.btnOpenPicker.addEventListener('click', ()=> MP.show()); }
  })();
  </script>
{% endblock %}
